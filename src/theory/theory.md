# 알고리즘 이론 정리
## 버블정렬
- 데이터를 인접한 것 끼리 비교해서 처음부터 끝까지 비교한다.
- 최악의 경우 : O(n^2), 최선의 경우 : O(n) => 이미 정렬되어 있을 경우

## 삽입정렬
- 두 번째 인덱스부터 정렬을 시작하여, 해당 인덱스부터 작은 값을 만날때까지 정렬을 진행한다.
- 최악의 경우 : O(n^2), 최선의 경우 : O(n)

## 선택정렬
- 가장 최소의 값을 찾고, 맨 앞의 값과 교체한다.
- 맨 앞 이후에 값들을 같은 방법으로 정렬한다.
- 최악의 경우: O(n^2)

## 퀵 정렬
- 기준점을 하나 정하고, 기준점보다 작은 것은 왼쪽으로, 큰 것은 오른쪽으로 보내는 함수를 작성한다.
- 왼쪽, 기준점, 오른쪽으로 나누는 함수를 작성한다.
- 시간복잡도는 O(nlogn)이다. 일반적으로 반씩 나누어진다고 생각했을때, 단계는 1/2씩 나누어진다. logn 만큼의 depth가 생기고, 그 depth에 n만큼의 비교 연산을 수행하므로 시간복잡도는 nlogn이라고 할 수 있다. 
- 최악의 경우 모든 경우를 비교해야할 때 O(n^2)이다.

##동적 계획법(Dynamic Programming)
- 상향식 접근법 : 가장 최하위의 해답으로 가장 최상단의 문제를 푸는 기법
- 중복되는 재활용 기법을 사용하여서 문제를 반복해서 해결할 수 있다.
- 메모리에 저장해놓고 사용을 하는 메모리제이션(memorization) 기법을 사용한다.

##분할 정복(Divide and Conquer)
- 문제를 잘게 쪼갠 후 해결하고 다시 합쳐 문제를 해결하는 방법
- 하향식 접근법 : 상위의 답을 구하기 위해서 아래로 쪼개가면서 문제를 푸는 기법
- 동적 계획법과 분할 정복의 공통점은 잘게 쪼갠다는 것이다.
