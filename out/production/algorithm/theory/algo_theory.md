# 알고리즘 이론 정리
## 버블정렬
- 데이터를 인접한 것 끼리 비교해서 처음부터 끝까지 비교한다.
- 최악의 경우 : O(n^2), 최선의 경우 : O(n) => 이미 정렬되어 있을 경우

## 삽입정렬
- 두 번째 인덱스부터 정렬을 시작하여, 해당 인덱스부터 작은 값을 만날때까지 정렬을 진행한다.
- 최악의 경우 : O(n^2), 최선의 경우 : O(n)

## 선택정렬
- 가장 최소의 값을 찾고, 맨 앞의 값과 교체한다.
- 맨 앞 이후에 값들을 같은 방법으로 정렬한다.
- 최악의 경우: O(n^2)

## 퀵 정렬
- 기준점을 하나 정하고, 기준점보다 작은 것은 왼쪽으로, 큰 것은 오른쪽으로 보내는 함수를 작성한다.
- 왼쪽, 기준점, 오른쪽으로 나누는 함수를 작성한다.
- 시간복잡도는 O(nlogn)이다. 일반적으로 반씩 나누어진다고 생각했을때, 단계는 1/2씩 나누어진다. logn 만큼의 depth가 생기고, 그 depth에 n만큼의 비교 연산을 수행하므로 시간복잡도는 nlogn이라고 할 수 있다. 
- 최악의 경우 모든 경우를 비교해야할 때 O(n^2)이다.

## 병합 정렬
- 재귀용법을 사용한다.
- 비교하고자 하는 데이터를 나눌수 없을 때까지 절반으로 계속 나누어 구한다.
- 절반으로 나누는 함수와, 그것을 병합할 수 있게끔 하는 병합함수로 나누어 구현한다.
- 병합할때, 각 첫번째 를 비교하여 더 작은 것을 더 왼쪽에 둔다.

## 동적 계획법(Dynamic Programming)
- 상향식 접근법 : 가장 최하위의 해답으로 가장 최상단의 문제를 푸는 기법
- 중복되는 재활용 기법을 사용하여서 문제를 반복해서 해결할 수 있다.
- 메모리에 저장해놓고 사용을 하는 메모이제이션(memoization) 기법을 사용한다.

## 분할 정복(Divide and Conquer)
- 문제를 잘게 쪼갠 후 해결하고 다시 합쳐 문제를 해결하는 방법
- 하향식 접근법 : 상위의 답을 구하기 위해서 아래로 쪼개가면서 문제를 푸는 기법
- 동적 계획법과 분할 정복의 공통점은 잘게 쪼갠다는 것이다.

## 이진탐색(binary search)
- 중간을 체크하여, 어느쪽에 값이 위치하는지를 탐색한다.
- 크기를 n이라하고, 비교연산의 횟수를 k라할 때, log2n =k, 빅오 표기법으로 나타내면 O(logn)이 된다.

## 순차탐색(sequential search)
- 데이터를 앞에서부터 차례대로 비교하여 원하는 데이터를 찾아내는 방식

## 그래프(graph)
- 정점(vetex) 또는 노트(node)와 간선(edge)로 표현하기 위해 사용한다.
- 가중치 그래프(Weighted Graph)
    - 간선의 비용이나 가중치가 할당되어있는 그래프
- 연결 그래프(Connected Graph) & 비연결 그래프(Disconnected Graph)
    - 연결 그래프
        - 무방향 그래프에 있는 모든 노드에 경로가 존재한다.
    - 비연결 그래프
        - 무방향 그래프에 특정 노드에 대해 경로가 존재하지 않는 경우
- 싸이클(cycle)
    - 시작과 종료 노드가 동일한 경우를 싸이클(cycle)이라 한다.
- 완전 그래프
    - 그래프의 모든 노드가 서로 연결되어있는 그래프
    - 
